import os
import re
import sys
from query import Query
from llm import Mistral
from langchain_core.chat_history import InMemoryChatMessageHistory

sys.path.append(os.path.join(os.path.dirname(__file__), "src"))

# Configuration
DEFAULT_LIMIT = 10
BODY_LENGTH = 1000
HISTORY_LIMIT = 4

# Patterns to detect sender-specific queries
# NOTE: These regex patterns were generated by AI and may need refinement
NAME_PATTERN = r"([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,2})"
SENDER_PATTERNS = [
    rf"(?i:did|has|have)\s+{NAME_PATTERN}\s+(?i:send|sent|email|write|wrote)",
    rf"(?i:emails?|messages?)\s+(?i:from|by)\s+{NAME_PATTERN}",
    rf"(?i:from|by)\s+{NAME_PATTERN}(?:\s|$|\?)",
    rf"{NAME_PATTERN}(?:'s)?\s+(?i:emails?|messages?)",
]

SYSTEM_PROMPT = """You are an email assistant. Answer questions using only the provided emails.
Reference the sender and subject when relevant. Be concise."""

# Formats a single email for display in the prompt
EMAIL_TEMPLATE = """From: {sender}
Subject: {subject}
Date: {date}
{body}
"""

# Full prompt structure sent to the LLM
RESPONSE_TEMPLATE = """{system}

Conversation History:
{history}

Emails:
{emails}

User Question: {question}

Answer:"""


class RAG:
    def __init__(self):
        self.query = Query()
        self.llm = Mistral()
        self.history = InMemoryChatMessageHistory()
        self.last_results = []

    def _extract_sender(self, question):
        """extract sender name from question if it's a sender-specific query"""
        for pattern in SENDER_PATTERNS:
            match = re.search(pattern, question)
            if match:
                return match.group(1)
        return None

    def ask(self, question, limit=DEFAULT_LIMIT):
        """answer question using email context"""
        try:
            recent_messages = self.history.messages[-HISTORY_LIMIT:]
            if recent_messages:
                hist_text = "\n".join(
                    f"{'User' if m.type == 'human' else 'Assistant'}: {m.content}"
                    for m in recent_messages
                )
            else:
                hist_text = "None"

            # sender queries need exact name matching, not semantic search
            sender_name = self._extract_sender(question)
            if sender_name:
                results = self.query.search_by_sender(sender_name, limit=limit)
            else:
                results = self.query.search_with_threads(question, limit=limit)

            # Include previous results for context continuity
            if self.last_results:
                seen = {r["email_id"] for r in results}
                for r in self.last_results:
                    if r["email_id"] not in seen:
                        results.append(r)
                        seen.add(r["email_id"])

            self.last_results = results

            if not results:
                return "No emails found matching that context."

            prompt = RESPONSE_TEMPLATE.format(
                system=SYSTEM_PROMPT,
                history=hist_text,
                emails=self._format(results),
                question=question,
            )
            response = self.llm.respond(prompt)

            self.history.add_user_message(question)
            self.history.add_ai_message(response)
            return response
        except Exception as e:
            return f"Error: {e}"

    def _format(self, results):
        """format email results for prompt"""
        emails = []
        for e in results:
            sender = e["sender"].split("@")[0]
            body = e.get("content", e["body"])[:BODY_LENGTH]
            emails.append(
                EMAIL_TEMPLATE.format(
                    sender=sender, subject=e["subject"], date=e["date"], body=body
                )
            )
        return "\n---\n".join(emails)

    def close(self):
        """cleanup"""
        self.query.close()
